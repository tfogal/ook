<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Ook : dynamic bricking" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Ook</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/tfogal/ook">View on GitHub</a>

          <h1 id="project_title">Ook</h1>
          <h2 id="project_tagline">simple dynamic bricking</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/tfogal/ook/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/tfogal/ook/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h1>

<p>This is ook, a simple library for providing bricked versions of a
dataset.</p>

<p>`Bricking' is the term we use in some visualization subfields to
refer to the process by which a large data set is carved into smaller
pieces.  The major reason one does this is for memory usage reasons.
Typically, a large data set exceeds the amount of physical memory
available on a machine.  One can load up a brick of the data, perform
any needed processing, and then throw the brick away.  By iterating
over this process, one can process the entire data set while only
needing enough memory for a single brick.</p>

<p>Ook essentially provides the illusion that your data set is already
stored as bricks.</p>

<h2>
<a name="what-ook-is-not" class="anchor" href="#what-ook-is-not"><span class="octicon octicon-link"></span></a>What Ook is Not</h2>

<p>Ook <em>only</em> provides a contiguous, bricked view of a data
set.  This means it may lack some features you desire.  You'll have to
provide them yourself.</p>

<p>Here are some related ideas which are out of scope for Ook:</p>

<ul>
<li>multiresolution.</li>
<li>file format abstraction.  Ook does not know about file formats.</li>
<li>memory handling.  Ook provides the tool; wield it how you will.</li>
<li>metadata handling</li>
<li>high-dimensional data.  Ook deals with 3D data only, though you can
hack lower dimensions with a <code>1</code>-sized dimension.</li>
</ul>

<h1>Documentation</h1>

<h2>
<a name="tutorial" class="anchor" href="#tutorial">
<span class="octicon octicon-link"></span></a>Tutorial</h2>

<p>There is <a href="tutorial.html">a tutorial available</a> to get you
started with Ook.  But if you just need some quick guidance, see <a
href="#usage">Usage</a>, below.</p>

<h2>
<a name="manpages" class="anchor" href="#manpages">
<span class="octicon octicon-link"></span></a>Man Pages</h2>

<p>Ook includes a set of manual pages, which are
also available online:
<ul>
  <li><a href="man/io-interface.7.html">io-interface.7</a>
  <li><a href="man/ookbrick.3.html">ookbrick.3</a>
  <li><a href="man/ookbricks.3.html">ookbricks.3</a>
  <li><a href="man/ookbricksize.3.html">ookbricksize</a>
  <li><a href="man/ookclose.3.html">ookclose.3</a>
  <li><a href="man/ookcreate.3.html">ookcreate.3</a>
  <li><a href="man/ookdimensions.3.html">ookdimensions.3</a>
  <li><a href="man/ookinit.3.html">ookinit.3</a>
  <li><a href="man/ookmaxbricksize.3.html">ookmaxbricksize.3</a>
  <li><a href="man/ookread.3.html">ookread.3</a>
  <li><a href="man/ookwrite.3.html">ookwrite.3</a>
</ul>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<h3>Quick Reference</h3>

<p>Ook is exported mostly as a set of function calls.  You'll need to
<code>#include</code> the header <code>ook.h</code> for the functions to be available.
All Ook functions begin with <code>ook</code>, are always spelled with lowercase
characters, and never contain underscores.</p>

<p>The important ones functions are:</p>

<pre><code>bool ookinit();
</code></pre>

<p><code>ookinit</code> is an initialization function for the library.
There is no corresponding deinitialization function; just make
sure all your files are closed.</p>

<pre><code>struct ookfile;
</code></pre>

<p><code>ookfile</code> is an opaque type which represents a file opened by Ook.
Note that you may have a file open in your own code and opened a second
time through Ook.  With a "header + data" type of file format, you
might do this just to read the header and then open it again via Ook
for accessing the data.</p>

<p>There is a limit to the number of open <code>struct ookfile</code>s a process
may have at any one time.  This limit is system-defined, but you may
safely assume it to be no less than 100.</p>

<pre><code>enum OOKTYPE;
</code></pre>

<p><code>OOKTYPE</code> is an enumeration which describes the underlying type of
the data.  The options are:</p>

<pre><code>OOK_I8,OOK_U8, OOK_I16,OOK_U16, OOK_I32,OOK_U32, OOK_I64,OOK_U64,
OOK_FLOAT, OOK_DOUBLE
</code></pre>

<p>The data type of a file cannot be changed once it is opened.</p>

<pre><code>struct ookfile* ookread(struct io, const char*,
                        const uint64_t voxels[3],
                        const size_t bricksize[3], const enum OOKTYPE,
                        const size_t components);
</code></pre>

<p><code>ookread</code> gives back a file used in basically all other
Ook function calls.  It only allows read access to a file.</p>

<p>In order, the arguments are: the IO interface to use, a filename
to open, the full dimensions of the file, the desired brick size,
the underlying type of the data, and the number of components in the
data.</p>

<pre><code>size_t ookbricks(const struct ookfile*);
</code></pre>

<p><code>ookbricks</code> returns the total number of bricks in the file.  You
might use it in code like this, for example:</p>

<pre><code>for(size_t i=0; i &lt; ookbricks(f); ++i) {
  /* process brick `i` */
}
</code></pre>

<p>You could technically calculate this yourself based on the volume and
brick size you gave Ook when you opened the file.</p>

<pre><code>void ookmaxbricksize(const struct ookfile*, size_t[3]);
</code></pre>

<p><code>ookmaxbricksize</code> simply returns the brick size you gave Ook when
you opened the file.  This is just for convenience; the intent is that
you can pass the <code>struct ookfile</code> around all over the place without
always duplicating its metadata.</p>

<pre><code>void ookbricksize(struct ookfile*, const size_t id, size_t bsize[3]);
</code></pre>

<p><code>ookbricksize</code> gives the brick size for a specific brick (<code>id</code>)
in the data set.  This can be smaller than what is given by
<code>ookmaxbricksize</code> in the case that the bricking size does not evenly
divide the domain.  In that case, bricks on the edge of the domain may
be smaller than other bricks.</p>

<pre><code>void ookbrick(struct ookfile*, size_t id, void* data);
</code></pre>

<p><code>ookbrick</code> is probably the most important function of the library.
It reads the data for a given brick into the provided pointer.  No
allocation is performed; Ook assumes <code>data</code> has enough memory to
perform the copy.</p>

<p>If you get segfaults in <code>ookbrick</code>, the most likely explanation is
that you are passing in an invalid pointer or a memory block which is
not large enough for the given brick.  Remember to calculate enough
space for multicomponent data and the width of each datum.</p>

<pre><code>void ookdimensions(const struct ookfile*, uint64_t[3]);
</code></pre>

<p>Like <code>ookmaxbricksize</code>, this is a convenience function so that you
do not need to communicate file metadata all over your program.  It
returns the volume size information you gave to Ook when you opened the
file.</p>

<pre><code>struct ookfile*
ookcreate(struct io, const char* filename, const uint64_t dims[3],
          const size_t bsize[3], enum OOKTYPE, size_t components);
</code></pre>

<p><code>ookcreate</code> is the "writing" analogy to
<code>ookread</code>.  The arguments are the same, but this gives write
access to the underlying file instead of read access.</p>

<p>Note the given file is truncated!</p>

<p>Ook will not detect if you open the same file multiple times with
any mixture of readers and writers.  The serialization of individual
readers/writers in this situation is undefined.</p>

<pre><code>void ookwrite(struct ookfile*, const size_t id, const void*);
</code></pre>

<p><code>ookwrite</code> is the opposite of <code>ookbrick</code>: it
writes the given data to the file at the correct positions for the
brick ID.</p>

<pre><code>int ookclose(struct ookfile*);
</code></pre>

<p><code>ookclose</code> closes a file which was opened by <code>ookread</code> or
<code>ookcreate</code>.  Any Ook calls which accept a <code>struct ookfile</code> give
undefined results after an <code>ookclose</code> operation on the same file.</p>

<p><em>All Ook files must be closed</em>.</p>

<p>Note that a close operation may be expensive.</p>

<p>A common error is to ignore the return value of
<code>ookclose</code>.  Write errors, in particular, are reported
during the close.  Code which does not check for errors on close should
be assumed to write invalid output files.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Ook maintained by <a href="https://github.com/tfogal">tom</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>
